# 第五章 Rails 中的控制器

## 课程概要：

本课程通过对控制器的学习，了解 Rails 如何控制业务逻辑，以及如何保护数据安全。并且完成购物和支付流程。

## 知识点：

1. Request 对象
2. Response 对象
3. Session 对象
4. Rspec 测试

## 课程背景

控制器 Controller 是 MVC 中调度员的角色，由它控制着流程的

# 5.1 控制器中的方法

## 概要

本课时讲解控制器中如何处理传入的参数和相应，以及如何使用回调，和 etag 缓存。

## 知识点

* params
* session
* cookies
* 回调
* etag
* csrf

## 正文

### 5.1.1 strong paramaters

Controller 是控制器的概念，所谓控制，指在网络传输中，接收参数和做出相应。Controller 有两种方式接收参数：GET 和 POST。两种方式均可通过 `params` 读取传递的内容。

Controller 的代码在 Rails 的 [ActionPack](https://github.com/rails/rails/tree/master/actionpack) 中。

在 Rails3之前的版本中，当接收传递的参数，用来更新资源属性时，可以设定 Model 的属性白名单，非报名单上的属性不允许通过参数传递的方式修改，比如：

```
class User < ActiveRecord::Base
  attr_accessible :name
end
```

在 Rails 4 之后，这个方法转为 [gem](https://github.com/rails/protected_attributes)，不再是 Rails 4 的核心功能，但将在 Rails 5 中重新回到核心功能中。现在，使用 `permit` 方法来过滤参数。使用 scaffold 创建的 Controller 默认使用了该方法：

```
class ProductsController < ApplicationController
  def create
    @product = Product.new(product_params)
    ...
  private
    def product_params
      params.require(:product).permit(:name, :price, :description)
    end
end
```

`permit` 可以设定关联关系的属性：

```
params.require(:product).permit(:name, :price, :description, variants_attributes: [:price, :size, :id, :_destroy])
```

`:id` 和 `:_destroy` 适用于上一章介绍的 `accepts_nested_attributes_for` 方法。


### 5.1.2 respond_to 方法

Controller 响应请求有多种结果，响应返回 `Status Code`，常见的有 200（成功响应），302（跳转），404（未找到资源），500（内部错误）。更多响应 Code 参考 [3.3 视图中的 AJAX 交互](../Chapter_3/3.3.md)。

一个 controller 的 action 对应一个请求，这样可以保持我们业务逻辑代码清晰，易维护。一个 action 可以响应一个请求的多中类型，这在我们第三章里已经有了介绍和演示。

Controller 使用 `respond_to` 方法，针对每一种请求类型，做出响应：

```
respond_to do |format|
  if @product.save
    format.html { redirect_to @product, notice: 'Product was successfully created.' }
    format.json { render :show, status: :created, location: @product }
  else
    format.html { render :new }
    format.json { render json: @product.errors, status: :unprocessable_entity }
  end
  format.js
end
```

当我们处理多个资源时，每个资源的 `create` 和 `update` 等资源方法，大多都具备相同的逻辑代码。除了特定的业务逻辑，他们都会响应典型的资源操作。 Rails 4.2 之前提供了 `respond_with` 访问，4.2 之后将它转为一个 gem，我们安装这个 gem：

```
gem "responders"
```

并且创建文件：

```
% rails g responders:install
      create  lib/application_responder.rb
      insert  config/application.rb
     prepend  app/controllers/application_controller.rb
      insert  app/controllers/application_controller.rb
      create  config/locales/responders.en.yml
```

默认，它只支持 :html，因为我们演示时，又使用到了 :json 和 :js，还有 :xml，我们将这些类型添加上：

```
class ApplicationController < ActionController::Base
  self.responder = ApplicationResponder
  respond_to :html, :xml, :json, :js
```

我们将刚才 `respond_to` 方法改成 `respond_with`，精简重复的代码（Dry up your code）：

```
def create
  @product = Product.create(product_params)
  respond_with(@product)
end
```

在 [6.4 I18n](../Chapter_6/6.4.md) 中，我们讲 I18n 文件做了整理，这里我们把 generator 创建的语言包，按照 6.4 一节中介绍的方式进行管理，并且增加中文提示。如此，我们不必为每个资源创建、修改等操作各自编写语言提示了。

### 5.1.3 session 和 cookies



### 5.1.4 回调

before_action

### 5.1.5 etag

### 5.1.6 csrf

在我们的布局（layout）页面，你可能已经看到这样一个辅助方法：

```
<%= csrf_meta_tags %>
```

打开页面的源码，我们可以看到：

```
<meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="O3Li25wJK0buXKRQRX4CzpAWheQIQ4VknCPe3KwNIFkIuUsbBApxl2jVVTd9IcmzR8oHLZI0qZpO39aLdNaBAQ==" />
```

当我使用表单的辅助方法 `form_for` 和 `form_tag` 时，表单会自动创建一个隐藏控件

```
<input type="hidden" name="authenticity_token" value="GI5YwKDhQA4pMlLRaUlpHugYdL5ygNe3Co6TL8PvZDsrRfEAOOIa36+7o7ZRFqJjP8T2d+j3+0nYcpt4GzTFYw==">
```

当我们使用 `remote: true` 时，这个控件又消失了，这样是不是不安全？不，ujs 在提交的时候，为我们自动补充上了 `authenticity_token` 参数

[http://guides.ruby-china.org/security.html](http://guides.ruby-china.org/security.html)





