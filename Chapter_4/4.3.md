# 4.3 模型中的关联关系（Relations）

## 概要：

本课时讲解 Rails 中 Model 和 Model 间的关联关系。

## 知识点：

1. belongs_to
2. has_one
3. has_many
4. has_and_belongs_to_many
5. self join

## 正文

### 导读

如果你对一对一关系，一对多关系，多对多关系并不十分了解的话，或者你对关系型数据库并不十分了解的话，建议你在阅读下面的内容前，先熟悉一下相关内容。因为我并不想照本宣科的讲解手册。我想讲的，是对它的理解，并且把我们的精力，放到设计我们的商城中。

本章涉及的知识，可以查看 [Active Record Associations](http://guides.rubyonrails.org/association_basics.html)，或者 [ActiveRecord::Associations::ClassMethods](http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html)。

接下来的内容，希望能帮助你理解模型间的关联关系。

### 4.3.1 模型间的关系

在前面的章节里，我们为商城设计了界面，并且使用了3个 model:

1. User，网站用户，使用 devise 提供了用户注册，登录功能。
2. Product，商品
3. Variant，商品类型

我们在前面讲解的过程中，或多或少提到了 Product 和 Variant 的关系。一个 Product 有多个 Variant。现在我们需要增加几个模型，模型是根据功能来的，我们的网店要增加哪些功能呢？

* 当用户购买实物商品的时候，我们是要输入它的收货地址（Address）。
* 当用户选择商品的时候，选择不同的颜色和大小，会有不同的价格（Variant）。
* 我们点击购买，会创建一个购物订单（Order），上面有我们选择的商品，应支付的金额，和订单的状态。

在我们的网店里，一个 User 有一个地址，每次购物的时候，会读取这个地址作为送货地址。

一个 Product 有多个 Variant，每个 Variant 保存它的颜色，大小等属性。

一个用户会有多个订单 Order，每个订单会显示购买的商品 Product，以及多条购买记录，每条记录显示购买的 Variant 的每个数量和应付的价格，这里我们使用 LineItem 表示订单的订单项。


### 4.3.2 外键

两个 model 之间，通过外键进行关联，Rails 中默认的外键名称是所属 model 的 `名称_id`，比如，User 有一条 Address 记录，那么 addresses 表上，需要增加一个数字类型的字段 `user_id`。而 User 的主键通常为 id 字段。有一些遗留的数据库，使用的外键可能不是按照 Rails 默认的格式，所以在声明外键关联时，需要指定 `foreign_key`。

在我们创建 Model 的时候，可以在 generate 命令上增加外键关联，我们现在创建 Address 这个 Model

```
rails g model address user:references state city address address2 zipcode receiver phone 
```

在创建的 migration 文件中：

```
create_table :addresses do |t|
  t.references :user, index: true, foreign_key: true
```


自动增加了外键关联，并且将 user_id 加入索引。如果是更改其他数据库，需要在 migration 文件内单独设置索引：

```
add_index "addresses", ["user_id"], name: "index_addresses_on_user_id"
```

模型间的关系，都是通过外键实现的，下面我们详细介绍模型间的关系，并且实现我们商城的 Model。

### 4.3.3 一对一关系

一对一关系的设定，再一次体现了 Rails 在开发中的便捷：

```
class User < ActiveRecord::Base
  has_one :address
end

class Address < ActiveRecord::Base
  belongs_to :user
end
```

要注意的是，`belongs_to :user` 中，`:user` 是单数，`has_one :address` 中，`:address` 也是单数。

我们进入到 console 里来测试一下：

```
user = User.first
user.address
=> nil
```

如何为 user 保存 address 呢？可以有多种方法，可以使用 Address 的类方法 `create`：

```
Address.create(user_id: user.id, ...)
```

我们也可以省去 id 的写法，直接写上所属的实例：

```
Address.create(user: user, ...)
```

也可以使用实例方法：

```
address = Address.new
address.user = user
address.save
```

或者：

```
user.address = Address.create( ... )
```

这种方法会产生两句 SQL，先是 insert 一个 address 到数据库，然后更新它的 user_id 为刚才的 user。我们可以换一个方法：

```
user.address = Address.new( ... )
```

它只产生一条 insert SQL，并且会带上 user_id 的值。

在创建关联关系时，还有这样的方法：

```
user.create_address( ... )
user.build_address( ... )
```

build_xxx 相当于 Address.new。create_xxx也会产生两条 SQL，每条 SQL 都包含在一个 transaction 中。

所以我们得出结论：

把一个未保存的实例，赋值给一对一关系时，它会自动保存，并且只有一条 sql 产生。

先 create 一个实例，再把赋值给一对一关系时，是先保存，再更新，产生两条 sql。

#### 4.3.3.1 保存子资源

当我们编写表单的时候，一个表单针对的是一个资源。当这个资源拥有（has_one 或 has_many）子资源时，我们可以在提交表单的时候，将它拥有的资源也保存到数据库中。

这时，我们需要在 User中，做一个声明：

```
class User < ActiveRecord::Base
  has_one :address
  accepts_nested_attributes_for :address
end
```

`accepts_nested_attributes_for` 会为 User 增加一个新的方法 `address_attributes=(attributes)`，这样，在创建 User 的 时候：

```
user_hash = { email: "test@123.com", password: "123456", password_confirmation: "123456", address_attributes: { receiver: "Some One", state: "Beijing", city: "Beijing", phone: "123456"} }
u = User.create(user_hash)
u.address
```

只要保存 User 的时候，传递入 Address 的参数，就可以把关联的 address 一并保存到数据库中了。

更新记录的时候，也可以使用同样的方法：

```
user_hash = { email: "changed@123.com", address_attributes: { receiver: "Other One" } }
user.update(user_hash)
```

但是，这里要注意，上面的方法会把之前旧记录的 user_id 设为 nil，然后插入一条新的记录。这并不能起到更新的作用，除非所有属性都重新复制，不然，新的 address 记录只有 receiver 这个值。

我们在 accepts_nested_attributes_for 后增加一个参数：

```
accepts_nested_attributes_for :address, update_only: true
```

这样，update 时候会更新已有的记录。

如果我们能增加 `update_only` 属性，为了避免创建无用的记录，需要在 hash 里指定子资源的 id：

```
user_hash = { email: "changed@123.com", address_attributes: { id: 1, receiver: "Other One" } }
user.update(user_hash)
```


#### 4.3.3.2 Form 中的子资源

在 model 中使用了 `accepts_nested_attributes_for` 方法，在 Form 中也有对应的方法：


```
<%= f.fields_for :address do |address_form| %>
  <div class="form-group">
    <%= address_form.label :state, class: "control-label" %><br />
    <%= address_form.text_field :state, class: "form-control" %>
  </div>
  ...
<% end %>
```

打开代码，在编辑一个用户的时候，我为它增加了一个 `f.fields_for` 的子表单，里面对应了子资源的属性。

我想，这并不难理解，不过我们用了 Devise 这个 gem，还需要做一点额外的设定。

打开 application_controller.rb，我们需要让 devise 支持传进来额外的参数：

```
class ApplicationController < ActionController::Base
  before_action :configure_permitted_parameters, if: :devise_controller?

  protected

  def configure_permitted_parameters
    devise_parameter_sanitizer.for(:sign_up) { |u| u.permit(:email, :password, :password_confirmation, :address_attributes) }
    devise_parameter_sanitizer.for(:account_update) { |u| u.permit(:email, :password, :password_confirmation, :current_password, address_attributes: [:state, :city, :address, :address2, :zipcode, :receiver, :phone] ) }
  end
end
```

在我们注册账号的时候，并没有提供 address 的表单，但是这样会在编辑的时候，也不会提供它，因为它是 nil，我们需要在编辑用户信息的时候，创建一个空的 address：

`views/devise/registrations/edit.html.erb`

```
<%= form_for(resource, as: resource_name, url: registration_path(resource_name), html: { method: :put }) do |f| %>
  <% resource.build_address if resource.address.nil? %>
  ...
```

当然，我们页可以在注册的时候提供地址表单，或者在购物的时候填写表单，大家不妨一试。

#### 4.3.3.3 删除关联的子资源

在上一节里，我们介绍了 delete 和 destroy 方法，我们可以使用这两个方法把关联的 address 删除掉：

```
u.address.delete
   SQL (10.0ms)  DELETE FROM "addresses" WHERE "addresses"."id" = ?  [["id", 2]]
```

或者：

```
u.address.destroy
   (0.1ms)  begin transaction
  SQL (0.7ms)  DELETE FROM "addresses" WHERE "addresses"."id" = ?  [["id", 3]]
   (9.2ms)  commit transaction
```

两者的区别在上一节介绍过，我们注意到，delete 直接发送数据库删除命令，而 destroy 会将删除命令放置到一个 sql 的事物中，因为它会触发模型中的回调，如果回调抛出异常，删除动作会失败。

在删除资源的时候，我们想把它拥有的资源一并删除，这时，我们需要给 has_one 方法，增加一个参数：

```
has_one :address, dependent: :destroy
```

dependent 可以接收五个参数：

参数 | 含义
-- | --
:destroy | 删除拥有的资源
:delete | 直接发送删除命令，不会执行回调
:nullify | 将拥有的资源外键设为 null
:restrict_with_exception | 如果拥有资源，会抛出异常，也就是说，当它 has_one 为 nil 的时候，才能正常删除它自己
:restrict_with_error | 如有拥有资源，会增加一个 errors 信息。

注意，在 belongs_to 上，也可以设置 dependent，它只有两个参数：

参数 | 含义
-- | --
:destroy | 删除它所属的资源
:delete | 删除它所属的资源，直接发送删除命令，不会执行回调

两种设定，出发角度是不同的，要选择业务场景进行设置。

















### 4.3.4 一对多关系

在电商系统里，一个用户是有多个订单（Order）的，这时我们需要用到的是 has_many 方法：

```
class User < ActiveRecord::Base
  has_many :orders
end
```

除了名称变为复数形式，返回的结果是数组，其他情形和“一对一”是一样的。

#### 4.3.4.1 counter_cache

“一对多”关系中，可以增加 counter_cache 属性：

```
class Post < ActiveRecord::Base
  belongs_to :user, counter_cache: true
end
```

这时，我们需要给 users 表增加一个字段：posts_count，当我们把一个 post 保存到一对多的关系中时，posts_count 会自动 +1，当把一个资源从关系中删除，该字段会 -1。这样我们不必去增加计算 user 有多少个post，只需要读该字段就可以了。

#### 4.3.4.2 多态

当一个资源，可以属于多个资源时，需要用到多态。举个栗子：

商品可以评论，文章可以评论，而评论 model 对任何一个资源都是一样的功能，所以，评论在 belongs_to 的后面，增加：

```
class Comment < ActiveRecord::Base
	belongs_to :commentable, polymorphic: true
end
```

Comment 的迁移文件，也相应的增加设定：

```
t.references :commentable, polymorphic: true, index: true
```

如果是手动添加字段，需要这样来写：

```
t.string :commentable_type
t.integer :commentable_id
```

说明，查找一个多态资源时，是根据拥有者的类型（type，一般是它的类名称）和 ID 进行匹配的。

包含评论的 model，也需要改动下：

```
class Product < ActiveRecord::Base
  has_many :commentable, as: :commentable
end

class Topic < ActiveRecord::Base
  has_many :commentable, as: :commentable
end
```

#### 4.3.4.3 保存和删除

当保存一个一对多关系时，可以很“形象”的使用：

```
product.variants << variant
```

执行 << 的时候，variant 的 product_id 会自动保存为 product.id。

如果 variant 是一个未保存到数据库的实例，<< 执行的时候会自动将它保存，并且赋予它 product_id 值。这是一步完成的，只有一条 SQL。比如：

```
product.variants << Variant.new
```

而如果是：

```
product.variants << Variant.create
```

会先把variant 保存到数据库，然后再更新它的 product_id 字段，这会产生两条 SQL。

这里也可以使用 build 方法，和上面“一对一关系”不同的是，它需要在一个 collection 上执行：

```
product.variants.build( ... )
```

这是查看 `product.variants`，会看到它包含了一个未保存的 variant（ID 为 nil）。当这个product.save 的时候，这个 variant 才会保存到数据库中。

删除资源的时候，可以使用：

```
product.variants.delete()
product.variants.destroy()
product.variants.clear
```

delete 不会真正删除掉资源，而是把它的外键（product_id）设为 nil，而 destroy 会真正的删除掉它并出发回调。

他们都可以传递进一个实例，或者实例的集合，而并不管这个实例是否真的属于它。

```
product.variants.delete(Variant.find(1))
product.variants.delete(Variant.find(1,2,3))
```

这样是不是太霸道了？所以，建议用第三个方法更稳妥些。clear 方法会把外键置为 nil。如果再 has_many 上声明了 `dependent: :destroy`，会用 destroy 方式把它们删除（有回调）。如果声明的是 `dependent: :delete_all`，会用 delete 方法（跳过回调）。这和一对一中描述是一致的。

当改动关系的时候，我们可以直接使用 `=`，假设我们有 ID 为1，2，3，4的 Variant：

```
product.variants = Variant.find(1,2)
```

这时会自动把1，2的 product_id 外键更新。

再次选择3，4的 variant：

```
product.variants = Variant.find(3,4)
```

会自动把3，4的 product_id 外键更新。

如果设置了`dependent: :destroy`，当1和2失去关联的时候，会把它们从数据库中删除掉。

#### 4.3.3.4 中间表

has_one 和 has_many，是两个 model 间的操作。我们可以增加一个中间模型，描述关系间的属性。

我们创建一个模型，Property，属性。属性保存的是“品牌”，“材质”，“适合性别”。“属性”会被每个商品引用，但是它并不保存每个商品具体的属性是什么。我们把属性值保存在这个中间模型里。

```
rails g model property name 
rails g model product_property value product:references property:references
```

product_property 就是这个充当关联桥梁的模型，它有两个 belongs_to，分别属于关系的两端。

为了让 Product 找到它关联的 Property，我们在 has_many 的基础上，增加 through 参数：

```
class ProductProperty < ActiveRecord::Base
  belongs_to :product
  belongs_to :property
end
```

作为中间表，它的名字是有自己的含义的，在早先的 Rails 版本中（ActiveRecord 之前版本），默认使用的是两边 Model 的单数名称联合的形式，也就是我们例子中的 “ProductProperty”。

我们已经介绍了一对多关系，我们在 Product 中引入这个中间表：

```
class Product < ActiveRecord::Base
  has_many :product_properties
  has_one :property, through: :product_properties
end
```




### 4.3.4 多对多关系




这段我也没想好

我们创建一个模型，OptionType，它保存的数据有：大小（Size），颜色（Color）。

再创建一个模型，OptionValue，它保存的数据是 S，M，L，Red，White，Yellow。

假设，一个 Product 有多个 OptionValue，但是，每个 OptionValue 属于专属的 OptionType 的：

OptionType | Option Value
-- | --
Size | S
Size | M
Size | L
Color | Red
Color | White
Color | Yellow

这时，OptionType  表充当的是关联的桥梁，也就是中间表。

中间表会我们创建需要的迁移文件：

```
rails g model option_type name position:integer [1]
rails g model product_option_type product:references option_type:references
rails g model option_value position:integer name option_type:references  
rails g migration CreateJoinTableOptionValueVariant option_value variant
```


### 4.3.5 多态连接

### 4.3.6 自连接




六中关系
belongs_to
has_one
has_many
has_many :through
has_one :through
has_and_belongs_to_many

migration
增删改查
自连接
中间表字段
Bi-directional 双向关联
Uni-directional 单向关联

model.build_prefix
association.build

业务逻辑：user.address, has_one
option_type, option_value